{"./":{"url":"./","title":"简介","keywords":"","body":"Airborder的技术文档 该文档叙述了开发中遇到的问题及对应的解决方案，常见的方法和接口封装等。 从github克隆使用 安装依赖 克隆项目后gitbook install 启动 gitbook serve 构建 gitbook build Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 14:03:08 "},"wxapp/":{"url":"wxapp/","title":"小程序","keywords":"","body":"小程序 小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 官方文档 微信小程序开发文档 开发者工具下载 以下章节暂时仅基于微信小程序 请求封装 公共方法 通讯录制作 常见问题汇总 Echarts的使用 IOS全面屏的底栏适配 setData({})遇到Promise请求 canvas绘制 分享 扫码 其他注意事项 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 13:55:18 "},"wxapp/RequestPackage.html":{"url":"wxapp/RequestPackage.html","title":"请求封装","keywords":"","body":"请求封装 在utils文件夹下建立base.js文件 let UrlConfig = {} UrlConfig.url = '此处填写公共url' class Base { // 图片上传（此处举例的是上传阿里云oss,如正常传服务器上，可以类比request封装） async uploadOss(options){ let ossData = await this.ossRequest() ossData = ossData.data return new Promise((resolve, reject) =>{ wx.uploadFile({ filePath: options.file, name: 'file', url: ossData.requestUri, // formData里的具体参数根据你获取到的ossSign数据来传 formData: { 'x-oss-meta-tag': 'dummy_etag_xxx', //我们公司阿里云设置要求 'key': ossData.bucketNameFile + '$' + '{filename}', // 阿里云AccesKey ID 'policy': ossData.encPolicy, // 加密规则 'OSSAccessKeyId': ossData.accessKeyId, // 阿里云 Access Key Secret 'signature': ossData.signature, // 签名 'success_action_status': '200' // 固定值200 }, success(res) { if (res.statusCode == 200) { console.log('图片上传成功200') let filename = options.file filename = filename.split('//')[1] if(filename.indexOf('/') > -1){ filename = filename.substring(4) } resolve(`${ossData.url}${filename}`) } else { console.log('图片上传成功不是200') reject(res) } }, fail (err) { console.log('图片上传失败',err) reject(err) } }) }) } // 请求封装 async request(param) { if (!param.method) { param.method = 'GET' } var nowTime = parseInt(new Date().getTime() / 1000) var expired = Number(wx.getStorageSync('expired')) var token if(nowTime > expired || !wx.getStorageSync('token')){ let tokenData = await this.login() wx.setStorageSync('token',tokenData.token_type + ' ' + tokenData.access_token) wx.setStorageSync('expired',tokenData.profile.expires_at) token = tokenData.token_type + ' ' + tokenData.access_token }else{ token = wx.getStorageSync('token') } return new Promise((resolve, reject) =>{ wx.request({ url: UrlConfig.url + param.url, method: param.method, dataType: 'json', header: { 'Content-Type': 'application/json', 'authorization': token }, data: param.data, success(res) { if (res.data.code == 100) { resolve(res.data) } else { //错误信息可根据code值再次封装 reject(res) } }, fail (err) { wx.showToast({ title: '网络错误', icon: 'none' }) reject(err) } }) }) } // 获取ossSign async ossRequest() { var nowTime = parseInt(new Date().getTime() / 1000) var expired = Number(wx.getStorageSync('expired')) var token if(nowTime > expired || !wx.getStorageSync('token')){ let tokenData = await this.login() wx.setStorageSync('token',tokenData.token_type + ' ' + tokenData.access_token) wx.setStorageSync('expired',tokenData.profile.expires_at) token = tokenData.token_type + ' ' + tokenData.access_token }else{ token = wx.getStorageSync('token') } return new Promise((resolve, reject) =>{ wx.request({ url: UrlConfig.url + '获取ossSign的接口', method: 'GET', dataType: 'json', header: { 'Content-Type': 'application/json', 'authorization': token }, success(res) { resolve(res) }, fail (err) { reject(err) } }) }) } // 登录 login() { let that = this return new Promise((resolve, reject) =>{ wx.login({ success: (res) => { if (res.code) { // 发起获取令牌请求 // console.log(res.code) wx.request({ method: 'POST', url: UrlConfig.url + 'Auth/AuthorizeWXSDK', data: { // appType值根据不同项目变化 appType: 1001, js_code: res.code }, dataType: 'json', success: (e) => { resolve(e.data) } }) } else { that.login() } }, fail (err) { reject(err) } }) }) } // 延时 sleep(time) { return new Promise((resolve) => { let timer = setTimeout(() => { clearTimeout(timer) resolve() }, time) }) } } export { Base } 在app.js中使用 // 引入 import { Base } from 'utils/base.js' var base = new Base() App({ onLaunch: async function () { if (wx.getStorageSync('token') === '') { console.log('token失效') let tokenData = await base.login() wx.setStorageSync('token',tokenData.token_type + ' ' + tokenData.access_token) wx.setStorageSync('expired',tokenData.profile.expires_at) } else { console.log('token获取成功') } }, globalData: { userInfo: null } }) 其他页面中使用 // 引入 import { Base } from '相对路径/utils/base.js' var base = new Base() // 使用 base.request({ ··· }) base.upload({ ··· }) Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-16 11:02:19 "},"wxapp/PublicFunction.html":{"url":"wxapp/PublicFunction.html","title":"公共方法","keywords":"","body":"公共方法封装 在utils文件夹下的util.js文件存放方法 输入框控制时间执行 function debounce(fn, wait) { let timer = null return () => { if (timer) { clearTimeout(timer) } timer = setTimeout(fn, wait) } } 输入框控制时间执行 function debounce(fn, wait) { let timer = null return () => { if (timer) { clearTimeout(timer) } timer = setTimeout(fn, wait) } } 时间戳转时间（全部带补零） function timeToString(time,num){ let new_date = new Date(time) // YYYY/MM/DD HH:mm:ss 格式（年/月/日 时:分:秒） if(num === 1){ new_date = new_date.getFullYear().toString() + '/' + ((new_date.getMonth() + 1) base64编码，配合encodeURIComponent使用 function base64_encode (str) { var c1, c2, c3; var base64EncodeChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; var i = 0, len = str.length, strin = ''; while (i > 2); strin += base64EncodeChars.charAt((c1 & 0x3) > 2); strin += base64EncodeChars.charAt(((c1 & 0x3) > 4)); strin += base64EncodeChars.charAt((c2 & 0xF) > 2); strin += base64EncodeChars.charAt(((c1 & 0x3) > 4)); strin += base64EncodeChars.charAt(((c2 & 0xF) > 6)); strin += base64EncodeChars.charAt(c3 & 0x3F) } return strin } base64解码，配合decodeURIComponent使用 function base64_decode (input) { var base64EncodeChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; var output = \"\"; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\"); while (i > 4); chr2 = ((enc2 & 15) > 2); chr3 = ((enc3 & 3) utf-8解码 function utf8_decode (utftext) { var string = ''; let i = 0; let c = 0; let c1 = 0; let c2 = 0; while (i 191) && (c 方法抛出 module.exports = { debounce: debounce, timeToString: timeToString, base64_encode: base64_encode, base64_decode: base64_decode, utf8_decode: utf8_decode } 页面中使用 // 引入 let utils = require('相对路径/utils/util.js') // 使用 utils.方法名 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-16 10:55:14 "},"wxapp/AddressBook.html":{"url":"wxapp/AddressBook.html","title":"通讯录制作","keywords":"","body":"通讯录制作 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 13:55:56 "},"wxapp/CommonQuestion/":{"url":"wxapp/CommonQuestion/","title":"常见问题汇总","keywords":"","body":"以下章节汇总了我在微信小程序开发中遇到的问题 Echarts的使用 IOS全面屏的底栏适配 setData({})遇到Promise请求 canvas绘制 分享 扫码 其他注意事项 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 13:02:37 "},"wxapp/CommonQuestion/UseEcharts.html":{"url":"wxapp/CommonQuestion/UseEcharts.html","title":"Echarts的使用","keywords":"","body":"微信小程序中Echarts的使用 使用 使用我这里不多加赘述，详细请看echarts-for-weixin 无法滑动与层级过高的问题 无法滑动 因为微信小程序上的echarts是用canvas画的，所以很多问题的产生是canvas导致的，在微信小程序中，canvas是作为原生组件存在，有着许多的限制。 在项目中，如果发现存在echarts的页面无法滑动，在你的echarts绘制wxml上加上属性disable-scroll=\"true\"即可，例如： 注：包裹echarts的组件盒子必须为最高级，外部不可以在添加任何的块，也不能设置任何的position属性 层级过高 层级过高也是canvas原生组件导致的，要覆盖在canvas上层，仅可使用cover-view,cover-image，小程序的官方文档有说明 小程序中echarts.js文件过大 echarts官方提供了一个在线定制网站，勾选你项目需要的配置项，构建出的echarts.min.js重命名为echarts.js，替换你项目中的echarts.js即可 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 09:55:40 "},"wxapp/CommonQuestion/FullScreenAdaptation.html":{"url":"wxapp/CommonQuestion/FullScreenAdaptation.html","title":"IOS全面屏的底栏适配","keywords":"","body":"IOS全面屏的底栏适配 背景：ios从iphone X开始进入全面屏时代，底栏出现了代替home键的横条，横条所在区域被称之为安全区域，这里指的全面屏适配就是适配安全区域，防止误触。 第一种：使用wx.getSystemInfo() 在app.js中使用 onLaunch: function (res) { wx.getSystemInfo({ success(res){ // 判断是不是iphone X及以上机型 if (res.model.search('iPhone X') != -1){ // 保存全局变量 app.globalData.isIpx = true }else{ app.globalData.isIpx = false } // 获取安全区域右下角纵坐标 let height1 = res.safeArea.bottom // 获取屏幕高度 let height2 = res.screenHeight // 相减为安全区域高度 let subHeight = height2 - height1 // 存缓存里 wx.setStorageSync('subHeight',subHeight) } }) } 第二种：使用css 微信小程序官方的兼容提案 padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); 如果遇到当前页面还有scroll-view标签，要动态计算高度时可配合wx.getSystemInfo()使用 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 09:55:36 "},"wxapp/CommonQuestion/PromiseRequest.html":{"url":"wxapp/CommonQuestion/PromiseRequest.html","title":"setData({})遇到Promise请求","keywords":"","body":"setData({})遇到Promise 请求 如果接口封装了Promise请求，那么在页面中使用经常会遇到一个问题，在页面重新渲染时需要先重置数据，再接口调用，将返回值赋值，但小程序提示无法判定你设置的数据，其实是由于小程序的setData({})方法导致的，小程序因为其性能原因，可能会因为你重置数据和接口赋值都操作了同一个数据，它无法判定应该如何设置该数据而导致报错。 解决办法： 在公共方法或者接口封装页面封装睡眠方法的Promise请求 // 延时 sleep(time) { return new Promise((resolve) => { let timer = setTimeout(() => { clearTimeout(timer) resolve() }, time) }) } 在接口响应完成后先调用等待方法，比如等待100毫秒，例 await XXXX.sleep(100) 注：XXXX表示为你封装页面抛出的方法，需在调用界面先引入定义 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 14:46:17 "},"wxapp/CommonQuestion/CanvasDraw.html":{"url":"wxapp/CommonQuestion/CanvasDraw.html","title":"canvas绘制","keywords":"","body":"canvas绘制 常见场景：新建内容 > 后端生成动态小程序码 > 前端显示 > 下载到手机 需求：小程序码中包含数据，虽可直接下载使用，但码一多或时间一长无法记清每个码的名称，将该码的名称与小程序合并为一张图下载至手机 这里举例小程序绘制和下载 1.下载至小程序本地 //imagePath为二维码路径，自行获取 getQrCode(imagePath){ let _this = this; return new Promise((resolve,reject) =>{ wx.downloadFile({ url: imagePath, //二维码路径 success: (res) => { if (res.statusCode === 200) { console.log('下载成功') resolve(res.tempFilePath) } else { wx.showToast({ title: '二维码下载到本地失败', icon: 'none', duration: 1000, }) reject(res) } }, fail: (error) => { reject(error) } }) }) } 2.绘制canvas 此处举例绘制一个400rpx * 400rpx的图，名字在小程序上方并居中 wxml部分 js部分 //codeSrc为上述方法返回的本地路径，name为小程序码名 async canvasFun(codeSrc,name){ const ctx = wx.createCanvasContext(\"myCanvas\") wx.createSelectorQuery().select('#canvas-container').boundingClientRect((rect) => { let height = rect.height let width = rect.width ctx.setFillStyle('#ffffff') ctx.fillRect(0, 0, width, height) ctx.setFontSize(14) ctx.setFillStyle('#303133') if (codeSrc) { ctx.drawImage(codeSrc, 15, 30, width - 30, height - 30) } if (name) { const metrics = ctx.measureText(name).width //测量文本信息 ctx.fillText(name, (width / 2) - (metrics / 2), 20) ctx.stroke() ctx.fill() } }).exec() setTimeout(() => { ctx.draw() },500) } wxss部分 .qr-box{ width: 400rpx; height: 400rpx; margin: 0 auto; } 下载到手机 页面制作下载按钮，点击下载 下载方法 // 保存图片 downloadPic(){ let _this = this // 先获取保存到相册权限 wx.getSetting({ success(authTemp) { if (authTemp.authSetting['scope.writePhotosAlbum'] != undefined && authTemp.authSetting['scope.writePhotosAlbum'] == false) { // 打开自定义授权弹窗，showAuth控制弹窗显示隐藏 _this.setData({ showAuth: true }) }else{ // 获取权限成功，canvas转图片 wx.canvasToTempFilePath({ canvasId: 'myCanvas', success: function (res) { let tempFilePath = res.tempFilePath wx.saveImageToPhotosAlbum({ filePath: tempFilePath, success() { wx.showToast({ title: '图片保存成功', icon: 'none', duration: 1000 }) }, fail: function () { wx.showToast({ title: '图片保存失败', icon: 'none', duration: 1000 }) } }) } }) } } }) } 自定义相册授权弹窗 wxml文件 提示 允许保存图片到你的相册？ 取消 确定 注：弹窗背景遮罩自行制作 js文件 // 自定义授权取消 refuseAuth(){ this.setData({ showAuth: false }) }, // 自定义授权确认 confirmAuth(res){ if (res.detail.authSetting['scope.writePhotosAlbum'] == true) { this.downloadPic() } else { wx.showToast({ title: '保存到相册授权未打开！', icon: 'none' }) } this.setData({ showAuth: false }) }, wxss文件 .join-box{ position: fixed; z-index: 11; width: 80%; height: 276rpx; left: 10%; top: 35%; background-color: #fff; border-radius: 8rpx; border: 1px solid #eee; } .join-content-box{ height: 180rpx; padding: 40rpx 48rpx 0; } .join-content-title{ text-align: center; font-size: 28rpx; font-family: PingFangSC-Medium, PingFang SC; font-weight: 600; color: #303133; line-height: 40rpx; margin-bottom: 20rpx; } .join-content{ font-size: 28rpx; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; color: #606266; line-height: 40rpx; text-align: center; } .join-max-box{ position: fixed; z-index: 11; width: 80%; height: 396rpx; left: 10%; top: 30%; background-color: #fff; border-radius: 8rpx; } .join-max-content-box{ height: 300rpx; padding: 40rpx 48rpx 0; } .join-button-box{ height: calc(96rpx - 2px); display: flex; align-items: center; justify-content: center; border-top: 1px solid #EBEDF0; } .join-button-box-left{ width: 50%; color: #303133; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #fff; border: none; border-right: 1px solid #EBEDF0; border-radius: unset; padding: 0; font-size: 28rpx; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; line-height: 40rpx; } .join-button-box-left::after{ border: none; } .join-button-box-right{ width: 50%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #fff; border: none; border-radius: unset; padding: 0; font-size: 28rpx; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; color: #036ED5; line-height: 40rpx; } .join-button-box-right::after{ border: none; } Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 14:51:00 "},"wxapp/CommonQuestion/Share.html":{"url":"wxapp/CommonQuestion/Share.html","title":"分享","keywords":"","body":"分享 这里仅叙述分享给微信好友和微信群 右上角三个点分享 触发的是Page.onShareAppMessage事件，官方文档，可配置项为title（转发标题），path（转发路径），imageUrl（自定义图片路径，注意：图片长宽比为5:4） 将参数放在对象中返回即可，每个页面需单独配置，不配置则分享当前页，标题默认小程序名，图片为当前页截图 参数携带 在配置path时，用url的方式方式拼接参数，例/page/xxx?user=xxx 参数接收 两种方式 1.分享页面内获取 在onLoad生命周期中获取，例 onLoad: function(options) { // 参数在options里，可自行打印查看 } 2.全局获取（如分享的都是同个页面，推荐） 在app.js的onShow方法内获取，需配合场景值使用，例 onShow: function (res) { // 判断是否为分享进入 if(res.scene === 1007 || res.scene === 1008){ // 分享的数据在返回值的query中 let queryObj = res.query // 可存入微信小程序缓存中使用 } } 按钮分享 在页面中使用button按钮，添加open-type=\"share\"，官方文档，点击触发的也是Page.onShareAppMessage事件，配置项如上，如存在该页面点击分享与右上角三个点分享有不同的业务，则可如此配置 onShareAppMessage: function(){ if (res.from === 'button') { // 来自页面内转发按钮，写按钮分享逻辑 } else { // 三个点，写三个点分享逻辑 } } Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 14:48:26 "},"wxapp/CommonQuestion/Scan.html":{"url":"wxapp/CommonQuestion/Scan.html","title":"扫码","keywords":"","body":"扫码 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 13:56:06 "},"wxapp/CommonQuestion/Else.html":{"url":"wxapp/CommonQuestion/Else.html","title":"其他注意事项","keywords":"","body":"其他注意事项 1.伪类 2.图片预览触发onShow事件 3.分享完触发onShow事件 4.小程序未关闭即锁屏或直接切换应用或直接回主页后再次打开微信直接进小程序处理 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 13:52:18 "},"vue/":{"url":"vue/","title":"vue","keywords":"","body":"vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 以下章节将会通过vue2和vue3分别记录 vue2 vue3 vue2和vue3的部分区别罗列 1.视图和组合式API vue2 vue2中使用视图来进行页面管理，例如 data () { return {} }, computed: {}, watch: {}, methods: {}, // 几个生命周期 created () {} mounted () {} vue3 vue3中仍可使用视图，但官方更推荐使用组合式API，使用setup()组件选项，详细可看官网，具体使用教程推荐此网站。 2.typescript的支持 vue2 支持typescript，但支持度不高，坑较多/ vue3 全面支持typescript，vue3的绝大部分就是用typescript写的，要上手vue3需要把typescript早点上手了。 3.数据拦截 以下转载于掘金的时樾同学 vue2 采用Object.defineProperty 实现对象的拦截 let data = { m:234, n:[1,34,4,5676], h:{ c:34 } } function observer(data){ if(typeof data === 'object'){ Object.keys(data).forEach(key=>{ defineReactive(data,key,data[key]) }) } } function defineReactive(obj,key,val){ Object.defineProperty(obj,key,{ get(){ console.log('get') return val }, set(newVal){ console.log('set') if(newVal !== val ) val = newVal } }) } 上面通过遍历data的数据，进行了一次简单的拦截；看似没有问题，但如果我们改变data.h.c是不会触发set钩子的，为什么？因为这里还没有实现递归，所以只拦截了最表面的一层，里面的则没有被拦截。 递归拦截对象 function defineReactive(obj,key,val){ observer(val) Object.defineProperty(obj,key,{ get(){ console.log('get') return val }, set(newVal){ console.log('set') if(newVal !== val ) val = newVal } }) } 递归拦截，只要在defineReactive函数再调一次observer函数把要拦截的值传给它就行。这样，就实现了对象的多层拦截。但是呢，现在是拦截不到数组的，当我们调用push,pop等方法它是不会触发set钩子的,为什么？因为Object.defineProperty压根就不支持数组的拦截。既然它不支持，那么我们只能拦截它的这些（'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'）改变自身数据的方法了。 数组的拦截 function arrayMethods(){ const arrProto = Array.prototype const arrayMethods = Object.create(arrProto) const methods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] methods.forEach(function (method) { const original = arrProto[method] Object.defineProperty(arrayMethods, method, { value: function v(...args) { console.log('set arrayMethods') return original.apply(this, args) } }) }) return arrayMethods } 以上就是对这些数组的原型方法进行了一个拦截，然后把它覆盖要拦截的数组的原型就行，下面简单修改一下observer function observer(data){ if(typeof data === 'object'){ if(Array.isArray(data)){ data.__proto__ = arrayMethods() }else{ Object.keys(data).forEach(key=>{ defineReactive(data,key,data[key]) }) } } } 在vue中，还会判断该key有没有__proto__,如果没有就直接把这些方法放到这个key的自身上，如果有就直接覆盖这个__proto__。 完整代码 function arrayMethods(){ const arrProto = Array.prototype const arrayMethods = Object.create(arrProto) const methods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] methods.forEach(function (method) { const original = arrProto[method] Object.defineProperty(arrayMethods, method, { value: function v(...args) { console.log('set arrayMethods') return original.apply(this, args) } }) }) return arrayMethods } function observer(data){ if(typeof data === 'object'){ if(Array.isArray(data)){ data.__proto__ = arrayMethods() }else{ Object.keys(data).forEach(key=>{ defineReactive(data,key,data[key]) }) } } } function defineReactive(obj,key,val){ observer(val) Object.defineProperty(obj,key,{ get(){ console.log('get') return val }, set(newVal){ console.log('set') if(newVal !== val ) val = newVal } }) } observer(data) vue3 使用proxy 直接上代码 let data = { m:234, n:[1,34,4,5676], h:{ c:34 } } function defineReactive(obj){ Object.keys(obj).forEach((key) => { if(typeof obj[key] === 'object'){ obj[key] = defineReactive(obj[key]) } }) return new Proxy(obj,{ get(target,key){ console.log('get') return target[key] }, set(target,key,val){ console.log('set') return target[key] = val } }) } data = defineReactive(data) Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 14:50:08 "},"vue/vue2/":{"url":"vue/vue2/","title":"vue2汇总","keywords":"","body":"vue2 Vue的线下通用率最高的版本，稳定，高效。 官方文档 vue-cli vuex vue router element vant Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-17 14:05:42 "},"vue/vue3/":{"url":"vue/vue3/","title":"vue3汇总","keywords":"","body":"vue3 Vue的next版本，现已公测，大航海时代的one piece。 官方文档 vuex next vue router next vant next element3 花果山团队基于element开发的社区版UI框架 element plus 一神秘团队开发的社区版UI框架 vite 尤雨溪大佬推荐的构建工具，目前为beta版 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-17 14:53:07 "},"ts/":{"url":"ts/","title":"typescript","keywords":"","body":"typescript Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-18 13:57:10 "}}