{"./":{"url":"./","title":"简介","keywords":"","body":"Airborder的技术文档 该文档叙述了开发中遇到的问题及对应的解决方案，常见的方法和接口封装等。 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-17 09:04:19 "},"wxapp/":{"url":"wxapp/","title":"小程序","keywords":"","body":"小程序 小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 以下章节暂时仅基于微信小程序 请求封装 公共方法 常见问题汇总 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-16 08:46:40 "},"wxapp/RequestPackage.html":{"url":"wxapp/RequestPackage.html","title":"请求封装","keywords":"","body":"请求封装 在utils文件夹下建立base.js文件 let UrlConfig = {} UrlConfig.url = '此处填写公共url' class Base { // 图片上传（此处举例的是上传阿里云oss,如正常传服务器上，可以类比request封装） async uploadOss(options){ let ossData = await this.ossRequest() ossData = ossData.data return new Promise((resolve, reject) =>{ wx.uploadFile({ filePath: options.file, name: 'file', url: ossData.requestUri, // formData里的具体参数根据你获取到的ossSign数据来传 formData: { 'x-oss-meta-tag': 'dummy_etag_xxx', //我们公司阿里云设置要求 'key': ossData.bucketNameFile + '$' + '{filename}', // 阿里云AccesKey ID 'policy': ossData.encPolicy, // 加密规则 'OSSAccessKeyId': ossData.accessKeyId, // 阿里云 Access Key Secret 'signature': ossData.signature, // 签名 'success_action_status': '200' // 固定值200 }, success(res) { if (res.statusCode == 200) { console.log('图片上传成功200') let filename = options.file filename = filename.split('//')[1] if(filename.indexOf('/') > -1){ filename = filename.substring(4) } resolve(`${ossData.url}${filename}`) } else { console.log('图片上传成功不是200') reject(res) } }, fail (err) { console.log('图片上传失败',err) reject(err) } }) }) } // 请求封装 async request(param) { if (!param.method) { param.method = 'GET' } var nowTime = parseInt(new Date().getTime() / 1000) var expired = Number(wx.getStorageSync('expired')) var token if(nowTime > expired || !wx.getStorageSync('token')){ let tokenData = await this.login() wx.setStorageSync('token',tokenData.token_type + ' ' + tokenData.access_token) wx.setStorageSync('expired',tokenData.profile.expires_at) token = tokenData.token_type + ' ' + tokenData.access_token }else{ token = wx.getStorageSync('token') } return new Promise((resolve, reject) =>{ wx.request({ url: UrlConfig.url + param.url, method: param.method, dataType: 'json', header: { 'Content-Type': 'application/json', 'authorization': token }, data: param.data, success(res) { if (res.data.code == 100) { resolve(res.data) } else { //错误信息可根据code值再次封装 reject(res) } }, fail (err) { wx.showToast({ title: '网络错误', icon: 'none' }) reject(err) } }) }) } // 获取ossSign async ossRequest() { var nowTime = parseInt(new Date().getTime() / 1000) var expired = Number(wx.getStorageSync('expired')) var token if(nowTime > expired || !wx.getStorageSync('token')){ let tokenData = await this.login() wx.setStorageSync('token',tokenData.token_type + ' ' + tokenData.access_token) wx.setStorageSync('expired',tokenData.profile.expires_at) token = tokenData.token_type + ' ' + tokenData.access_token }else{ token = wx.getStorageSync('token') } return new Promise((resolve, reject) =>{ wx.request({ url: UrlConfig.url + '获取ossSign的接口', method: 'GET', dataType: 'json', header: { 'Content-Type': 'application/json', 'authorization': token }, success(res) { resolve(res) }, fail (err) { reject(err) } }) }) } // 登录 login() { let that = this return new Promise((resolve, reject) =>{ wx.login({ success: (res) => { if (res.code) { // 发起获取令牌请求 // console.log(res.code) wx.request({ method: 'POST', url: UrlConfig.url + 'Auth/AuthorizeWXSDK', data: { // appType值根据不同项目变化 appType: 1001, js_code: res.code }, dataType: 'json', success: (e) => { resolve(e.data) } }) } else { that.login() } }, fail (err) { reject(err) } }) }) } // 延时 sleep(time) { return new Promise((resolve) => { let timer = setTimeout(() => { clearTimeout(timer) resolve() }, time) }) } } export { Base } 在app.js中使用 // 引入 import { Base } from 'utils/base.js' var base = new Base() App({ onLaunch: async function () { if (wx.getStorageSync('token') === '') { console.log('token失效') let tokenData = await base.login() wx.setStorageSync('token',tokenData.token_type + ' ' + tokenData.access_token) wx.setStorageSync('expired',tokenData.profile.expires_at) } else { console.log('token获取成功') } }, globalData: { userInfo: null } }) 其他页面中使用 // 引入 import { Base } from '相对路径/utils/base.js' var base = new Base() // 使用 base.request({ ··· }) base.upload({ ··· }) Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-16 11:02:19 "},"wxapp/PublicFunction.html":{"url":"wxapp/PublicFunction.html","title":"公共方法","keywords":"","body":"公共方法封装 在utils文件夹下的util.js文件存放方法 输入框控制时间执行 function debounce(fn, wait) { let timer = null return () => { if (timer) { clearTimeout(timer) } timer = setTimeout(fn, wait) } } 输入框控制时间执行 function debounce(fn, wait) { let timer = null return () => { if (timer) { clearTimeout(timer) } timer = setTimeout(fn, wait) } } 时间戳转时间（全部带补零） function timeToString(time,num){ let new_date = new Date(time) // YYYY/MM/DD HH:mm:ss 格式（年/月/日 时:分:秒） if(num === 1){ new_date = new_date.getFullYear().toString() + '/' + ((new_date.getMonth() + 1) base64编码，配合encodeURIComponent使用 function base64_encode (str) { var c1, c2, c3; var base64EncodeChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; var i = 0, len = str.length, strin = ''; while (i > 2); strin += base64EncodeChars.charAt((c1 & 0x3) > 2); strin += base64EncodeChars.charAt(((c1 & 0x3) > 4)); strin += base64EncodeChars.charAt((c2 & 0xF) > 2); strin += base64EncodeChars.charAt(((c1 & 0x3) > 4)); strin += base64EncodeChars.charAt(((c2 & 0xF) > 6)); strin += base64EncodeChars.charAt(c3 & 0x3F) } return strin } base64解码，配合decodeURIComponent使用 function base64_decode (input) { var base64EncodeChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; var output = \"\"; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\"); while (i > 4); chr2 = ((enc2 & 15) > 2); chr3 = ((enc3 & 3) utf-8解码 function utf8_decode (utftext) { var string = ''; let i = 0; let c = 0; let c1 = 0; let c2 = 0; while (i 191) && (c 方法抛出 module.exports = { debounce: debounce, timeToString: timeToString, base64_encode: base64_encode, base64_decode: base64_decode, utf8_decode: utf8_decode } 页面中使用 // 引入 let utils = require('相对路径/utils/util.js') // 使用 utils.方法名 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-16 10:55:14 "},"wxapp/CommonQuestion.html":{"url":"wxapp/CommonQuestion.html","title":"常见问题汇总","keywords":"","body":"以下章节汇总了我在微信小程序开发中遇到的问题 Echarts的使用 IOS全面屏的底栏适配 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-16 15:26:57 "},"wxapp/UseEcharts.html":{"url":"wxapp/UseEcharts.html","title":"Echarts的使用","keywords":"","body":"微信小程序中Echarts的使用 使用 使用我这里不多加赘述，详细请看echarts-for-weixin 无法滑动与层级过高的问题 无法滑动 因为微信小程序上的echarts是用canvas画的，所以很多问题的产生是canvas导致的，在微信小程序中，canvas是作为原生组件存在，有着许多的限制。 在项目中，如果发现存在echarts的页面无法滑动，在你的echarts绘制wxml上加上属性disable-scroll=\"true\"即可，例如： 注：包裹echarts的组件盒子必须为最高级，外部不可以在添加任何的块，也不能设置任何的position属性 层级过高 层级过高也是canvas原生组件导致的，要覆盖在canvas上层，仅可使用cover-view,cover-image，小程序的官方文档有说明 小程序中echarts.js文件过大 echarts官方提供了一个在线定制网站，勾选你项目需要的配置项，构建出的echarts.min.js重命名为echarts.js，替换你项目中的echarts.js即可 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-16 15:04:03 "},"wxapp/FullScreenAdaptation.html":{"url":"wxapp/FullScreenAdaptation.html","title":"IOS全面屏的底栏适配","keywords":"","body":"IOS全面屏的底栏适配 背景：ios从iphone X开始进入全面屏时代，底栏出现了代替home键的横条，横条所在区域被称之为安全区域，这里指的全面屏适配就是适配安全区域，防止误触。 第一种：使用wx.getSystemInfo() 在app.js中使用 onLaunch: function (res) { wx.getSystemInfo({ success(res){ // 判断是不是iphone X及以上机型 if (res.model.search('iPhone X') != -1){ // 保存全局变量 app.globalData.isIpx = true }else{ app.globalData.isIpx = false } // 获取安全区域右下角纵坐标 let height1 = res.safeArea.bottom // 获取屏幕高度 let height2 = res.screenHeight // 相减为安全区域高度 let subHeight = height2 - height1 // 存缓存里 wx.setStorageSync('subHeight',subHeight) } }) } 第二种：使用css 微信小程序官方的兼容提案 padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); 如果遇到当前页面还有scroll-view标签，要动态计算高度时可配合wx.getSystemInfo()使用 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-16 15:44:23 "},"vue/":{"url":"vue/","title":"vue","keywords":"","body":"vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 以下章节将会通过vue2和vue3分别记录 vue2 vue3 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-17 09:20:24 "},"vue/vue2/":{"url":"vue/vue2/","title":"vue2","keywords":"","body":"vue2 Vue的线下通用率最高的版本，稳定，高效。 官方文档 cli官方文档 element官方文档 vant官方文档 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-17 10:43:36 "},"vue/vue3/":{"url":"vue/vue3/","title":"vue3","keywords":"","body":"vue3 Vue的next版本，现已公测，大航海时代的one piece。 官方文档 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-17 09:19:20 "}}