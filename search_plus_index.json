{"./":{"url":"./","title":"🎅 简介","keywords":"","body":" Airborder的技术文档 该文档叙述了开发中遇到的问题及对应的解决方案，常见的方法和接口封装等。 从github克隆使用 安装依赖 克隆项目后gitbook install 启动 gitbook serve 构建 gitbook build Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-21 15:00:13 "},"wxapp/":{"url":"wxapp/","title":"🎄 小程序","keywords":"","body":" 小程序 小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 官方文档 微信小程序开发文档 开发者工具下载 以下章节暂时仅基于微信小程序 请求封装 公共方法 通讯录制作 常见问题汇总 Echarts的使用 IOS全面屏的底栏适配 setData({})遇到Promise请求 canvas绘制 分享 扫码 其他注意事项 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-21 15:00:50 "},"wxapp/RequestPackage.html":{"url":"wxapp/RequestPackage.html","title":"请求封装","keywords":"","body":" 请求封装 在utils文件夹下建立base.js文件 let UrlConfig = {} UrlConfig.url = '此处填写公共url' class Base { // 图片上传（此处举例的是上传阿里云oss,如正常传服务器上，可以类比request封装） async uploadOss(options){ let ossData = await this.ossRequest() ossData = ossData.data return new Promise((resolve, reject) =>{ wx.uploadFile({ filePath: options.file, name: 'file', url: ossData.requestUri, // formData里的具体参数根据你获取到的ossSign数据来传 formData: { 'x-oss-meta-tag': 'dummy_etag_xxx', //我们公司阿里云设置要求 'key': ossData.bucketNameFile + '$' + '{filename}', // 阿里云AccesKey ID 'policy': ossData.encPolicy, // 加密规则 'OSSAccessKeyId': ossData.accessKeyId, // 阿里云 Access Key Secret 'signature': ossData.signature, // 签名 'success_action_status': '200' // 固定值200 }, success(res) { if (res.statusCode == 200) { console.log('图片上传成功200') let filename = options.file filename = filename.split('//')[1] if(filename.indexOf('/') > -1){ filename = filename.substring(4) } resolve(`${ossData.url}${filename}`) } else { console.log('图片上传成功不是200') reject(res) } }, fail (err) { console.log('图片上传失败',err) reject(err) } }) }) } // 请求封装 async request(param) { if (!param.method) { param.method = 'GET' } var nowTime = parseInt(new Date().getTime() / 1000) var expired = Number(wx.getStorageSync('expired')) var token if(nowTime > expired || !wx.getStorageSync('token')){ let tokenData = await this.login() wx.setStorageSync('token',tokenData.token_type + ' ' + tokenData.access_token) wx.setStorageSync('expired',tokenData.profile.expires_at) token = tokenData.token_type + ' ' + tokenData.access_token }else{ token = wx.getStorageSync('token') } return new Promise((resolve, reject) =>{ wx.request({ url: UrlConfig.url + param.url, method: param.method, dataType: 'json', header: { 'Content-Type': 'application/json', 'authorization': token }, data: param.data, success(res) { if (res.data.code == 100) { resolve(res.data) } else { //错误信息可根据code值再次封装 reject(res) } }, fail (err) { wx.showToast({ title: '网络错误', icon: 'none' }) reject(err) } }) }) } // 获取ossSign async ossRequest() { var nowTime = parseInt(new Date().getTime() / 1000) var expired = Number(wx.getStorageSync('expired')) var token if(nowTime > expired || !wx.getStorageSync('token')){ let tokenData = await this.login() wx.setStorageSync('token',tokenData.token_type + ' ' + tokenData.access_token) wx.setStorageSync('expired',tokenData.profile.expires_at) token = tokenData.token_type + ' ' + tokenData.access_token }else{ token = wx.getStorageSync('token') } return new Promise((resolve, reject) =>{ wx.request({ url: UrlConfig.url + '获取ossSign的接口', method: 'GET', dataType: 'json', header: { 'Content-Type': 'application/json', 'authorization': token }, success(res) { resolve(res) }, fail (err) { reject(err) } }) }) } // 登录 login() { let that = this return new Promise((resolve, reject) =>{ wx.login({ success: (res) => { if (res.code) { // 发起获取令牌请求 // console.log(res.code) wx.request({ method: 'POST', url: UrlConfig.url + 'Auth/AuthorizeWXSDK', data: { // appType值根据不同项目变化 appType: 1001, js_code: res.code }, dataType: 'json', success: (e) => { resolve(e.data) } }) } else { that.login() } }, fail (err) { reject(err) } }) }) } // 延时 sleep(time) { return new Promise((resolve) => { let timer = setTimeout(() => { clearTimeout(timer) resolve() }, time) }) } } export { Base } 在app.js中使用 // 引入 import { Base } from 'utils/base.js' var base = new Base() App({ onLaunch: async function () { if (wx.getStorageSync('token') === '') { console.log('token失效') let tokenData = await base.login() wx.setStorageSync('token',tokenData.token_type + ' ' + tokenData.access_token) wx.setStorageSync('expired',tokenData.profile.expires_at) } else { console.log('token获取成功') } }, globalData: { userInfo: null } }) 其他页面中使用 // 引入 import { Base } from '相对路径/utils/base.js' var base = new Base() // 使用 base.request({ ··· }) base.upload({ ··· }) Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:12:54 "},"wxapp/PublicFunction.html":{"url":"wxapp/PublicFunction.html","title":"公共方法","keywords":"","body":" 公共方法封装 在utils文件夹下的util.js文件存放方法 防抖 function debounce(fn, wait) { let timer = null return () => { if (timer) { clearTimeout(timer) } timer = setTimeout(fn, wait) } } 节流 function throttle(fn, delay){ let valid = true return () => { if(!valid){ //休息时间 暂不接客 return false } // 工作时间，执行函数并且在间隔期内把状态位设为无效 valid = false setTimeout(() => { fn() valid = true }, delay) } } 时间戳转时间（全部带补零） function timeToString(time,num){ let new_date = new Date(time) // YYYY/MM/DD HH:mm:ss 格式（年/月/日 时:分:秒） if(num === 1){ new_date = new_date.getFullYear().toString() + '/' + ((new_date.getMonth() + 1) base64编码，配合encodeURIComponent使用 function base64_encode (str) { var c1, c2, c3; var base64EncodeChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; var i = 0, len = str.length, strin = ''; while (i > 2); strin += base64EncodeChars.charAt((c1 & 0x3) > 2); strin += base64EncodeChars.charAt(((c1 & 0x3) > 4)); strin += base64EncodeChars.charAt((c2 & 0xF) > 2); strin += base64EncodeChars.charAt(((c1 & 0x3) > 4)); strin += base64EncodeChars.charAt(((c2 & 0xF) > 6)); strin += base64EncodeChars.charAt(c3 & 0x3F) } return strin } base64解码，配合decodeURIComponent使用 function base64_decode (input) { var base64EncodeChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; var output = \"\"; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\"); while (i > 4); chr2 = ((enc2 & 15) > 2); chr3 = ((enc3 & 3) utf-8解码 function utf8_decode (utftext) { var string = ''; let i = 0; let c = 0; let c1 = 0; let c2 = 0; while (i 191) && (c 方法抛出 module.exports = { debounce: debounce, throttle: throttle, timeToString: timeToString, base64_encode: base64_encode, base64_decode: base64_decode, utf8_decode: utf8_decode } 页面中使用 // 引入 let utils = require('相对路径/utils/util.js') // 使用 utils.方法名 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:12:47 "},"wxapp/AddressBook.html":{"url":"wxapp/AddressBook.html","title":"通讯录制作","keywords":"","body":" 通讯录制作 可使用vant的IndexBar组件，官方文档，但因为这个组件外部不可在套用块（会导致右侧索引失效）以及全屏仅有此组件时才能完美触发所有方法导致业务操作困难，故自定义一通讯录。 wxml文件 {{ item.anchor }} {{ item }} 注：scroll-view的配置请看官方文档 js文件 data: { // 人员列表 peopleList: [], // 索引列表 indexList: [], // 默认激活下标 activeIndex: 0, // 设置滚动高度 scrollTop: 0, // 标识是否为点击滚动，true为点击索引触发的滚动，false则不是 bindScroll: false, } // 右侧跳转 anchorFun(e){ let index = e.currentTarget.dataset.index let winWith = wx.getSystemInfoSync().windowWidth let topHeight = 0 let peopleList = this.data.peopleList for(let i = 0; i = topList[i-1]){ _this.setData({ activeIndex: i - 1 }) } } } }, // 人员排序方法 peopleListSortFun(peopleList){ let list = [ { anchor: 'A', list: [] }, { anchor: 'B', list: [] }, { anchor: 'C', list: [] }, { anchor: 'D', list: [] }, { anchor: 'E', list: [] }, { anchor: 'F', list: [] }, { anchor: 'G', list: [] }, { anchor: 'H', list: [] }, { anchor: 'I', list: [] }, { anchor: 'J', list: [] }, { anchor: 'K', list: [] }, { anchor: 'L', list: [] }, { anchor: 'M', list: [] }, { anchor: 'N', list: [] }, { anchor: 'O', list: [] }, { anchor: 'P', list: [] }, { anchor: 'Q', list: [] }, { anchor: 'R', list: [] }, { anchor: 'S', list: [] }, { anchor: 'T', list: [] }, { anchor: 'U', list: [] }, { anchor: 'V', list: [] }, { anchor: 'W', list: [] }, { anchor: 'X', list: [] }, { anchor: 'Y', list: [] }, { anchor: 'Z', list: [] }, { anchor: '#', list: [] } ] let charList = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'] peopleList.forEach(item => { // 只取名称的第一个字符 let firstStr = item.nickName.substr(0,1) // 使用pinyin插件将其转为拼音，仅包含拼音的第一个字母 let firstPY = pinyin.getFirstLetter(firstStr) // 转大写 firstPY = firstPY.toLocaleUpperCase() // 将不满足条件的重设为# if(charList.indexOf(firstPY) === -1){ firstPY = '#' } // 放入数组 list.forEach(value => { if(value.anchor === firstPY){ value.list.push(item) } }) }) // 将所有空数组过滤 let lastList = list.filter(item => { if(item.list.length > 0){ return item } }) return lastList }, // 初始人员列表设置 peopleFun(peopleList){ peopleList = this.peopleListSortFun(peopleList) let num = 0 let allSearchList = [] let indexList = [] let topList = [0] let topHeight = 0 let winWith = wx.getSystemInfoSync().windowWidth // 记录每个锚点需滚动多少 for(let i = 0; i { indexList.push(item.anchor) }) this.setData({ peopleList: peopleList, indexList: indexList, topList: topList }) }, // 调用 onShow: function() { this.peopleFun(接口获取到的数据) } 注：文字转拼音插件的使用，这里我用的是wl-pinyin，使用方法 wxss文件 /* 主滚动页 */ .scroll-anchor{ /* 高度根据实际项目变化 */ height: 100vh; } .anchor-title-box{ height: 60rpx; padding: 0 32rpx; display: flex; align-items: center; font-size: 28rpx; color: #303133; } .activeIndex-anchor-title-box{ color: #036ED5; } .people-list{ height: 100rpx; width: 100%; display: flex; align-items: center; border-top: 1px solid #F0F1F3; background-color: #fff; padding: 0 32rpx; } .avatar{ height: 68rpx; width: 68rpx; margin-right: 40rpx; border-radius: 50%; box-shadow: 0 0 3px 0px rgba(0, 0, 0, 0.35); } .people-list-name{ font-size: 28rpx; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; color: #303133; line-height: 40rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: calc(100% - 168rpx); } .people-new-image{ height: 40rpx; width: 40rpx; margin-left: 20rpx; } .people-list:last-of-type{ border-bottom: 1px solid #F0F1F3; } /* 侧栏索引 */ .anchor-box{ position: fixed; width: 32rpx; height: 100%; top: 0; right: 6rpx; background-color: transparent; display: flex; align-items: center; flex-direction: column; justify-content: center; z-index: 9; } .anchor-box .anchor-text{ height: 32rpx; display: flex; align-items: center; justify-content: center; width: 100%; font-size: 24rpx; color: #C0C4CC; margin-bottom: 10rpx; } .anchor-box .active-anchor-text{ background-color: #606266; border-radius: 50%; } Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:12:26 "},"wxapp/CommonQuestion/":{"url":"wxapp/CommonQuestion/","title":"常见问题汇总","keywords":"","body":" 以下章节汇总了我在微信小程序开发中遇到的问题 Echarts的使用 IOS全面屏的底栏适配 setData({})遇到Promise请求 canvas绘制 分享 扫码 其他注意事项 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:13:49 "},"wxapp/CommonQuestion/UseEcharts.html":{"url":"wxapp/CommonQuestion/UseEcharts.html","title":"Echarts的使用","keywords":"","body":" 微信小程序中Echarts的使用 使用 使用我这里不多加赘述，详细请看echarts-for-weixin。 无法滑动与层级过高的问题 无法滑动 因为微信小程序上的echarts是用canvas画的，所以很多问题的产生是canvas导致的，在微信小程序中，canvas是作为原生组件存在，有着许多的限制。 在项目中，如果发现存在echarts的页面无法滑动，在你的echarts绘制wxml上加上属性disable-scroll=\"true\"即可，例如： 注：包裹echarts的组件盒子必须为最高级，外部不可以在添加任何的块，也不能设置任何的position属性。 层级过高 层级过高也是canvas原生组件导致的，要覆盖在canvas上层，仅可使用cover-view,cover-image，小程序的官方文档有说明。 小程序中echarts.js文件过大 echarts官方提供了一个在线定制网站，勾选你项目需要的配置项，构建出的echarts.min.js重命名为echarts.js，替换你项目中的echarts.js即可。 限制 不可自定义tooltip，小程序中tooltip的formatter方法不可返回标签字符串，仅可使用普通字符串文本。 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:14:13 "},"wxapp/CommonQuestion/FullScreenAdaptation.html":{"url":"wxapp/CommonQuestion/FullScreenAdaptation.html","title":"IOS全面屏的底栏适配","keywords":"","body":" IOS全面屏的底栏适配 背景：ios从iphone X开始进入全面屏时代，底栏出现了代替home键的横条，横条所在区域被称之为安全区域，这里指的全面屏适配就是适配安全区域，防止误触。 第一种：使用wx.getSystemInfo() 在app.js中使用 onLaunch: function (res) { wx.getSystemInfo({ success(res){ // 判断是不是iphone X及以上机型 if (res.model.search('iPhone X') != -1){ // 保存全局变量 app.globalData.isIpx = true }else{ app.globalData.isIpx = false } // 获取安全区域右下角纵坐标 let height1 = res.safeArea.bottom // 获取屏幕高度 let height2 = res.screenHeight // 相减为安全区域高度 let subHeight = height2 - height1 // 存缓存里 wx.setStorageSync('subHeight',subHeight) } }) } 第二种：使用css 微信小程序官方的兼容提案 padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom); 如果遇到当前页面还有scroll-view标签，要动态计算高度时可配合wx.getSystemInfo()使用 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:13:16 "},"wxapp/CommonQuestion/PromiseRequest.html":{"url":"wxapp/CommonQuestion/PromiseRequest.html","title":"setData({})遇到Promise请求","keywords":"","body":" setData({})遇到Promise 请求 如果接口封装了Promise请求，那么在页面中使用经常会遇到一个问题，在页面重新渲染时需要先重置数据，再接口调用，将返回值赋值，但小程序提示无法判定你设置的数据，其实是由于小程序的setData({})方法导致的，小程序因为其性能原因，可能会因为你重置数据和接口赋值都操作了同一个数据，它无法判定应该如何设置该数据而导致报错。 解决办法： 在公共方法或者接口封装页面封装睡眠方法的Promise请求 // 延时 sleep(time) { return new Promise((resolve) => { let timer = setTimeout(() => { clearTimeout(timer) resolve() }, time) }) } 在接口响应完成后先调用等待方法，比如等待100毫秒，例 await XXXX.sleep(100) 注：XXXX表示为你封装页面抛出的方法，需在调用界面先引入定义 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:13:33 "},"wxapp/CommonQuestion/CanvasDraw.html":{"url":"wxapp/CommonQuestion/CanvasDraw.html","title":"canvas绘制","keywords":"","body":" canvas绘制 常见场景：新建内容 > 后端生成动态小程序码 > 前端显示 > 下载到手机 需求：小程序码中包含数据，虽可直接下载使用，但码一多或时间一长无法记清每个码的名称，将该码的名称与小程序合并为一张图下载至手机 这里举例小程序绘制和下载 1.下载至小程序本地 //imagePath为二维码路径，自行获取 getQrCode(imagePath){ let _this = this; return new Promise((resolve,reject) =>{ wx.downloadFile({ url: imagePath, //二维码路径 success: (res) => { if (res.statusCode === 200) { console.log('下载成功') resolve(res.tempFilePath) } else { wx.showToast({ title: '二维码下载到本地失败', icon: 'none', duration: 1000, }) reject(res) } }, fail: (error) => { reject(error) } }) }) } 2.绘制canvas 此处举例绘制一个400rpx * 400rpx的图，名字在小程序上方并居中 wxml部分 js部分 //codeSrc为上述方法返回的本地路径，name为小程序码名 async canvasFun(codeSrc,name){ const ctx = wx.createCanvasContext(\"myCanvas\") wx.createSelectorQuery().select('#canvas-container').boundingClientRect((rect) => { let height = rect.height let width = rect.width ctx.setFillStyle('#ffffff') ctx.fillRect(0, 0, width, height) ctx.setFontSize(14) ctx.setFillStyle('#303133') if (codeSrc) { ctx.drawImage(codeSrc, 15, 30, width - 30, height - 30) } if (name) { const metrics = ctx.measureText(name).width //测量文本信息 ctx.fillText(name, (width / 2) - (metrics / 2), 20) ctx.stroke() ctx.fill() } }).exec() setTimeout(() => { ctx.draw() },500) } wxss部分 .qr-box{ width: 400rpx; height: 400rpx; margin: 0 auto; } 下载到手机 页面制作下载按钮，点击下载 下载方法 // 保存图片 downloadPic(){ let _this = this // 先获取保存到相册权限 wx.getSetting({ success(authTemp) { if (authTemp.authSetting['scope.writePhotosAlbum'] != undefined && authTemp.authSetting['scope.writePhotosAlbum'] == false) { // 打开自定义授权弹窗，showAuth控制弹窗显示隐藏 _this.setData({ showAuth: true }) }else{ // 获取权限成功，canvas转图片 wx.canvasToTempFilePath({ canvasId: 'myCanvas', success: function (res) { let tempFilePath = res.tempFilePath wx.saveImageToPhotosAlbum({ filePath: tempFilePath, success() { wx.showToast({ title: '图片保存成功', icon: 'none', duration: 1000 }) }, fail: function () { wx.showToast({ title: '图片保存失败', icon: 'none', duration: 1000 }) } }) } }) } } }) } 自定义相册授权弹窗 wxml文件 提示 允许保存图片到你的相册？ 取消 确定 注：弹窗背景遮罩自行制作 js文件 // 自定义授权取消 refuseAuth(){ this.setData({ showAuth: false }) }, // 自定义授权确认 confirmAuth(res){ if (res.detail.authSetting['scope.writePhotosAlbum'] == true) { this.downloadPic() } else { wx.showToast({ title: '保存到相册授权未打开！', icon: 'none' }) } this.setData({ showAuth: false }) }, wxss文件 .join-box{ position: fixed; z-index: 11; width: 80%; height: 276rpx; left: 10%; top: 35%; background-color: #fff; border-radius: 8rpx; border: 1px solid #eee; } .join-content-box{ height: 180rpx; padding: 40rpx 48rpx 0; } .join-content-title{ text-align: center; font-size: 28rpx; font-family: PingFangSC-Medium, PingFang SC; font-weight: 600; color: #303133; line-height: 40rpx; margin-bottom: 20rpx; } .join-content{ font-size: 28rpx; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; color: #606266; line-height: 40rpx; text-align: center; } .join-max-box{ position: fixed; z-index: 11; width: 80%; height: 396rpx; left: 10%; top: 30%; background-color: #fff; border-radius: 8rpx; } .join-max-content-box{ height: 300rpx; padding: 40rpx 48rpx 0; } .join-button-box{ height: calc(96rpx - 2px); display: flex; align-items: center; justify-content: center; border-top: 1px solid #EBEDF0; } .join-button-box-left{ width: 50%; color: #303133; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #fff; border: none; border-right: 1px solid #EBEDF0; border-radius: unset; padding: 0; font-size: 28rpx; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; line-height: 40rpx; } .join-button-box-left::after{ border: none; } .join-button-box-right{ width: 50%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: #fff; border: none; border-radius: unset; padding: 0; font-size: 28rpx; font-family: PingFangSC-Regular, PingFang SC; font-weight: 400; color: #036ED5; line-height: 40rpx; } .join-button-box-right::after{ border: none; } Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:13:05 "},"wxapp/CommonQuestion/Share.html":{"url":"wxapp/CommonQuestion/Share.html","title":"分享","keywords":"","body":" 分享 这里仅叙述分享给微信好友和微信群 右上角三个点分享 触发的是Page.onShareAppMessage事件，官方文档，可配置项为title（转发标题），path（转发路径），imageUrl（自定义图片路径，注意：图片长宽比为5:4） 将参数放在对象中返回即可，每个页面需单独配置，不配置则分享当前页，标题默认小程序名，图片为当前页截图 参数携带 在配置path时，用url的方式方式拼接参数，例/page/xxx?user=xxx 参数接收 两种方式 1.分享页面内获取 在onLoad生命周期中获取，例 onLoad: function(options) { // 参数在options里，可自行打印查看 } 2.全局获取（如分享的都是同个页面，推荐） 在app.js的onShow方法内获取，需配合场景值使用，例 onShow: function (res) { // 判断是否为分享进入 if(res.scene === 1007 || res.scene === 1008){ // 分享的数据在返回值的query中 let queryObj = res.query // 可存入微信小程序缓存中使用 } } 按钮分享 在页面中使用button按钮，添加open-type=\"share\"，官方文档，点击触发的也是Page.onShareAppMessage事件，配置项如上，如存在该页面点击分享与右上角三个点分享有不同的业务，则可如此配置 onShareAppMessage: function(){ if (res.from === 'button') { // 来自页面内转发按钮，写按钮分享逻辑 } else { // 三个点，写三个点分享逻辑 } } Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:14:07 "},"wxapp/CommonQuestion/Scan.html":{"url":"wxapp/CommonQuestion/Scan.html","title":"扫码","keywords":"","body":" 扫码 小程序内部扫码 调用wx.scanCode()方法，官方文档，所有的成功回调都在success里，例如只允许扫小程序码，可以在返回值的scanType里判断，例： wx.scanCode({ success: res => { let type = res.scanType if(type === 'WX_CODE'){ //执行其他操作 }else{ //执行不是小程序码的操作，例如文字提示 } } }) 值的获取 正常情况下，二维码携带的值是在返回值的result里返回的，仅需decodeURIComponent(res.result)即可解码获取值。 还有一种情况，后端将值拼接在path里返回了，这种情况下，需用split()方法将传参先从res.path里切割下来，再用decodeURIComponent()方法解码获取值。 微信扫码进小程序 微信扫码进入小程序需先判断场景值，根据场景值列表存在三种场景，1047:扫描小程序码，1048:长按图片识别小程序码，1049:扫描手机相册中选取的小程序码，在app.js中的onShow方法里通过scene判断： onShow: function (res) { if(res.scene === 1047 || res.scene === 1048 || res.scene === 1049){ //为外部扫码进入 }else{ //其他 } } 值的获取 仍旧是在app.js中的onShow方法里，但通过query.scene判断: onShow: function (res) { if(res.scene === 1047 || res.scene === 1048 || res.scene === 1049){ let scanResult = decodeURIComponent(res.query.scene) //scanResult为小程序码中的参数，执行后续操作 }else{ //其他 } } Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:13:58 "},"wxapp/CommonQuestion/Else.html":{"url":"wxapp/CommonQuestion/Else.html","title":"其他注意事项","keywords":"","body":" 其他注意事项 1.选择器支持 小程序仅支持的伪类仅有before和after两种，选择器也仅支持类选择器，id选择器，标签选择器，兄弟选择器，详情请看官方文档。 2.图片预览触发onShow事件 小程序中调用图片预览一般使用小程序的官方api，wx.previewImage方法，使用方法请看官方文档，而在使用过程中你会发现图片预览结束会触发该页面的onShow方法，但往往很多重新渲染逻辑都写在此方法中，但仅预览图片并不想触发重新渲染，解决办法，例 //在data里定义一个是否预览的参数 data: { // 没在预览 isNotPreview: false, }, //在预览方法中重定义，方法名可自定 imagePreview(e) { this.setData({ isNotPreview: true }) }, //在onShow方法最上定义，判断现在是预览结束后触发的刷新，重置预览参数，直接退出后续方法 onShow: function() { if(this.data.isNotPreview){ this.setData({ isNotPreview: false }) return } } 3.分享完触发onShow事件 无论是三个点分享还是按钮点击分享，在分享完自动返回页面后也如预览一样会触发该页面的onShow方法，解决方法也类似。 //在data里定义一个是否分享的参数 data: { // 没在分享 isPageShare: false, }, //在onShow方法最上定义，判断现在是分享结束后触发的刷新，重置分享参数，直接退出后续方法 onShow: function() { if(this.data.isPageShare){ this.setData({ isPageShare: false }) return } }, //在分享方法中重定义，方法名固定 onShareAppMessage: function() { this.setData({ isPageShare: true }) } 4.小程序未关闭即锁屏或直接切换应用或直接回主页后再次打开微信直接进小程序处理 此处的处理与你在app.js里处理了scene场景值有关，因为小程序从哪种场景值进入，在不退出小程序的情况下再次触发小程序重载（例如标题描述的几种情况皆会触发），其场景值仍旧不变，如果逻辑仅判断场景值则会导致某些错误，解决办法，往往需判断场景值的情况下都是要接收该场景值时所传递的参数，仅需判断是否包含所需参数即可，因为上述情况重载仅保留了场景值，参数皆为空值。 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:13:26 "},"vue/":{"url":"vue/","title":"🔔 vue","keywords":"","body":" vue Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 以下章节将会通过vue2和vue3分别记录 vue2 vue3 vue2和vue3的部分区别罗列 1.视图和组合式API vue2 vue2中使用视图来进行页面管理，例如 data () { return {} }, computed: {}, watch: {}, methods: {}, // 几个生命周期 created () {} mounted () {} vue3 vue3中仍可使用视图，但官方更推荐使用组合式API，使用setup()组件选项，详细可看官网，具体使用教程推荐此网站。 2.typescript的支持 vue2 支持typescript，但支持度不高，坑较多/ vue3 全面支持typescript，vue3的绝大部分就是用typescript写的，要上手vue3需要把typescript早点上手了。 3.数据拦截 以下转载于掘金的时樾同学 vue2 采用Object.defineProperty 实现对象的拦截 let data = { m:234, n:[1,34,4,5676], h:{ c:34 } } function observer(data){ if(typeof data === 'object'){ Object.keys(data).forEach(key=>{ defineReactive(data,key,data[key]) }) } } function defineReactive(obj,key,val){ Object.defineProperty(obj,key,{ get(){ console.log('get') return val }, set(newVal){ console.log('set') if(newVal !== val ) val = newVal } }) } 上面通过遍历data的数据，进行了一次简单的拦截；看似没有问题，但如果我们改变data.h.c是不会触发set钩子的，为什么？因为这里还没有实现递归，所以只拦截了最表面的一层，里面的则没有被拦截。 递归拦截对象 function defineReactive(obj,key,val){ observer(val) Object.defineProperty(obj,key,{ get(){ console.log('get') return val }, set(newVal){ console.log('set') if(newVal !== val ) val = newVal } }) } 递归拦截，只要在defineReactive函数再调一次observer函数把要拦截的值传给它就行。这样，就实现了对象的多层拦截。但是呢，现在是拦截不到数组的，当我们调用push,pop等方法它是不会触发set钩子的,为什么？因为Object.defineProperty压根就不支持数组的拦截。既然它不支持，那么我们只能拦截它的这些（'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'）改变自身数据的方法了。 数组的拦截 function arrayMethods(){ const arrProto = Array.prototype const arrayMethods = Object.create(arrProto) const methods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] methods.forEach(function (method) { const original = arrProto[method] Object.defineProperty(arrayMethods, method, { value: function v(...args) { console.log('set arrayMethods') return original.apply(this, args) } }) }) return arrayMethods } 以上就是对这些数组的原型方法进行了一个拦截，然后把它覆盖要拦截的数组的原型就行，下面简单修改一下observer function observer(data){ if(typeof data === 'object'){ if(Array.isArray(data)){ data.__proto__ = arrayMethods() }else{ Object.keys(data).forEach(key=>{ defineReactive(data,key,data[key]) }) } } } 在vue中，还会判断该key有没有__proto__,如果没有就直接把这些方法放到这个key的自身上，如果有就直接覆盖这个__proto__。 完整代码 function arrayMethods(){ const arrProto = Array.prototype const arrayMethods = Object.create(arrProto) const methods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'] methods.forEach(function (method) { const original = arrProto[method] Object.defineProperty(arrayMethods, method, { value: function v(...args) { console.log('set arrayMethods') return original.apply(this, args) } }) }) return arrayMethods } function observer(data){ if(typeof data === 'object'){ if(Array.isArray(data)){ data.__proto__ = arrayMethods() }else{ Object.keys(data).forEach(key=>{ defineReactive(data,key,data[key]) }) } } } function defineReactive(obj,key,val){ observer(val) Object.defineProperty(obj,key,{ get(){ console.log('get') return val }, set(newVal){ console.log('set') if(newVal !== val ) val = newVal } }) } observer(data) vue3 使用proxy 直接上代码 let data = { m:234, n:[1,34,4,5676], h:{ c:34 } } function defineReactive(obj){ Object.keys(obj).forEach((key) => { if(typeof obj[key] === 'object'){ obj[key] = defineReactive(obj[key]) } }) return new Proxy(obj,{ get(target,key){ console.log('get') return target[key] }, set(target,key,val){ console.log('set') return target[key] = val } }) } data = defineReactive(data) Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-21 15:01:49 "},"vue/vue2/":{"url":"vue/vue2/","title":"vue2汇总","keywords":"","body":" vue2 Vue的线下通用率最高的版本，稳定，高效。 文档 官方文档 vue-cli vuex vue router element vant Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-23 16:23:13 "},"vue/vue3/":{"url":"vue/vue3/","title":"vue3汇总","keywords":"","body":" vue3 Vue的next版本，现已公测，大航海时代的one piece。 文档 官方文档 vuex next vue router next vant next element3 花果山团队基于element开发的社区版UI框架 element plus 一神秘团队开发的社区版UI框架 vite 尤雨溪大佬推荐的构建工具，目前为beta版 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-23 16:22:59 "},"ts/":{"url":"ts/","title":"🎁 typescript","keywords":"","body":" typescript TypeScript是JavaScript类型的超集，它可以编译成纯JavaScript。 TypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-21 15:01:56 "},"else/":{"url":"else/","title":"🎉 其他","keywords":"","body":" 其他 章节目录 UnicodeEmoji 亦云分享调研 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-24 16:42:23 "},"else/UnicodeEmoji.html":{"url":"else/UnicodeEmoji.html","title":"UnicodeEmoji","keywords":"","body":" Unicode Emoji 来源：v12.1emoji列表 win10快捷键win + . Smileys & Emotion face-smiling 😀 😃 😄 😁 😆 😅 🤣 😂 🙂 🙃 😉 😊 😇 face-affection 🥰 😍 🤩 😘 😗 ☺ 😚 😙 face-tongue 😋 😛 😜 🤪 😝 🤑 face-hand 🤗 🤭 🤫 🤔 face-neutral-skeptical 🤐 🤨 😐 😑 😶 😏 😒 🙄 😬 🤥 face-sleepy 😌 😔 😪 🤤 😴 face-unwell 😷 🤒 🤕 🤢 🤮 🤧 🥵 🥶 🥴 😵 🤯 face-hat 🤠 🥳 face-glasses 😎 🤓 🧐 face-concerned 😕 😟 🙁 ☹ 😮 😯 😲 😳 🥺 😦 😧 😨 😰 😥 😢 😭 😱 😖 😣 😞 😓 😩 😫 🥱 face-negative 😤 😡 😠 🤬 😈 👿 💀 ☠ face-costume 🤡 👹 👺 👻 👽 👾 🤖 cat-face 😺 😸 😹 😻 😼 😽 🙀 😿 😾 monkey-face 🙈 🙉 🙊 emotion 💋 💌 💘 💝 💖 💗 💓 💞 💕 💟 ❣ 💔 ❤ 🧡 💛 💚 💙 💜 🤎 🖤 🤍 💯 💢 💥 💫 💦 💨 🕳 💣 💬 👁️‍🗨️ 🗨 🗯 💭 💤 People & Body hand-fingers-open 🤚 🖐 ✋ 🖖 hand-fingers-partial 👌 🤏 ✌ 🤞 🤟 🤘 🤙 hand-single-finger 👈 👉 👆 🖕 👇 ☝ hand-fingers-closed 👍 👎 ✊ 👊 🤛 🤜 hands 👏 🙌 👐 🤲 🤝 🙏 hand-prop ✍ 💅 🤳 body-parts 💪 🦾 🦿 🦵 🦶 👂 🦻 🧠 🦷 🦴 👀 👁 👅 👄 person 👶 🧒 👦 👧 🧑 👱 👨 🧔 👱‍♂️ 👨‍🦰 👨‍🦱 👨‍🦳 👨‍🦲 👩 👱‍♀️ 👩‍🦰 👩‍🦱 👩‍🦳 👩‍🦲 🧓 👴 👵 person-gesture 🙍 🙍‍♂️ 🙍‍♀️ 🙎 🙎‍♂️ 🙎‍♀️ 🙅 🙅‍♂️ 🙅‍♀️ 🙆 🙆‍♂️ 🙆‍♀️ 💁 💁‍♂️ 💁‍♀️ 🙋 🙋‍♂️ 🙋‍♀️ 🧏 🧏‍♂️ 🧏‍♀️ 🙇 🙇‍♂️ 🙇‍♀️ 🤦 🤦‍♂️ 🤦‍♀️ 🤷 🤷‍♂️ 🤷‍♀️ person-role 👨‍⚕️ 👩‍⚕️ 👨‍🎓 👩‍🎓 👨‍🏫 👩‍🏫 👨‍⚖️ 👩‍⚖️ 👨‍🌾 👩‍🌾 👨‍🍳 👩‍🍳 👨‍🔧 👩‍🔧 👨‍🏭 👩‍🏭 👨‍💼 👩‍💼 👨‍🔬 👩‍🔬 👨‍💻 👩‍💻 👨‍🎤 👩‍🎤 👨‍🎨 👩‍🎨 👨‍✈️ 👩‍✈️ 👨‍🚀 👩‍🚀 👨‍🚒 👩‍🚒 👮 👮‍♂️ 👮‍♀️ 🕵 🕵️‍♂️ 🕵️‍♀️ 💂 💂‍♂️ 💂‍♀️ 👷 👷‍♂️ 👷‍♀️ 🤴 👸 👳 👳‍♂️ 👳‍♀️ 👲 🧕 🤵 👰 🤰 🤱 person-fantasy 👼 🎅 🤶 🦸 🦸‍♂️ 🦸‍♀️ 🦹 🦹‍♂️ 🦹‍♀️ 🧙 🧙‍♂️ 🧙‍♀️ 🧚 🧚‍♂️ 🧚‍♀️ 🧛 🧛‍♂️ 🧛‍♀️ 🧜 🧜‍♂️ 🧜‍♀️ 🧝 🧝‍♂️ 🧝‍♀️ 🧞 🧞‍♂️ 🧞‍♀️ 🧟 🧟‍♂️ 🧟‍♀️ person-activity 💆 💆‍♂️ 💆‍♀️ 💇 💇‍♂️ 💇‍♀️ 🚶 🚶‍♂️ 🚶‍♀️ 🧍 🧍‍♂️ 🧍‍♀️ 🧎 🧎‍♂️ 🧎‍♀️ 👨‍🦯 👩‍🦯 👨‍🦼 👩‍🦼 👨‍🦽 👩‍🦽 🏃 🏃‍♂️ 🏃‍♀️ 💃 🕺 🕴 👯 👯‍♂️ 👯‍♀️ 🧖 🧖‍♂️ 🧖‍♀️ 🧗 🧗‍♂️ 🧗‍♀️ person-sport 🤺 🏇 ⛷ 🏂 🏌 🏌️‍♂️ 🏌️‍♀️ 🏄 🏄‍♂️ 🏄‍♀️ 🚣 🚣‍♂️ 🚣‍♀️ 🏊 🏊‍♂️ 🏊‍♀️ ⛹ ⛹️‍♂️ ⛹️‍♀️ 🏋 🏋️‍♂️ 🏋️‍♀️ 🚴 🚴‍♂️ 🚴‍♀️ 🚵 🚵‍♂️ 🚵‍♀️ 🤸 🤸‍♂️ 🤸‍♀️ 🤼 🤼‍♂️ 🤼‍♀️ 🤽 🤽‍♂️ 🤽‍♀️ 🤾 🤾‍♂️ 🤾‍♀️ 🤹 🤹‍♂️ 🤹‍♀️ person-resting 🧘 🧘‍♂️ 🧘‍♀️ 🛀 🛌 family 🧑‍🤝‍🧑 👭 👫 👬 💏 👩‍❤️‍💋‍👨 👨‍❤️‍💋‍👨 👩‍❤️‍💋‍👩 💑 👩‍❤️‍👨 👨‍❤️‍👨 👩‍❤️‍👩 👪 👨‍👩‍👦 👨‍👩‍👧 👨‍👩‍👧‍👦 👨‍👩‍👦‍👦 👨‍👩‍👧‍👧 👨‍👨‍👦 👨‍👨‍👧 👨‍👨‍👧‍👦 👨‍👨‍👦‍👦 👨‍👨‍👧‍👧 👩‍👩‍👦 👩‍👩‍👧 👩‍👩‍👧‍👦 👩‍👩‍👦‍👦 👩‍👩‍👧‍👧 👨‍👦 👨‍👦‍👦 👨‍👧 👨‍👧‍👦 👨‍👧‍👧 👩‍👦 👩‍👦‍👦 👩‍👧 👩‍👧‍👦 👩‍👧‍👧 person-symbol 🗣 👤 👥 👣 Component skin-tone 🏻 🏼 🏽 🏾 🏿 hair-style 🦰 🦱 🦳 🦲 Animals & Nature animal-mammal 🐵 🐒 🦍 🦧 🐕 🦮 🐕‍🦺 🐩 🐺 🦊 🦝 🐱 🐈 🦁 🐯 🐅 🐆 🦄 🦓 🦌 🐂 🐃 🐄 🐷 🐖 🐗 🐽 🐏 🐑 🐐 🐪 🐫 🦙 🦒 🐘 🦏 🦛 🐭 🐁 🐀 🐹 🐰 🐇 🐿 🦔 🦇 🐨 🐼 🦥 🦦 🦨 🦘 🦡 🐾 animal-bird 🦃 🐓 🐣 🐤 🐥 🐦 🐧 🕊 🦅 🦆 🦢 🦉 🦩 🦚 🦜 animal-amphibian 🐸 animal-reptile 🐊 🦎 🐍 🐲 🐉 🦕 🦖 animal-marine 🐳 🐋 🐬 🐟 🐡 🦈 🐙 🐚 animal-bug 🐌 🦋 🐜 🐝 🐞 🦗 🕷 🕸 🦂 🦟 🦠 plant-flower 💐 🌸 💮 🏵 🌹 🥀 🌺 🌻 🌼 🌷 plant-other 🌱 🌲 🌳 🌴 🌵 🌾 🌿 ☘ 🍀 🍁 🍂 🍃 Food & Drink food-fruit 🍇 🍈 🍉 🍊 🍋 🍌 🍍 🥭 🍎 🍏 🍑 🍒 🍓 🥝 🍅 🥥 food-vegetable 🥑 🍆 🥔 🥕 🌽 🌶 🥒 🥬 🥦 🧄 🧅 🍄 🥜 🌰 food-prepared 🍞 🥐 🥖 🥨 🥯 🥞 🧇 🧀 🍖 🍗 🥩 🥓 🍔 🍟 🍕 🌭 🥪 🌮 🌯 🥙 🧆 🥚 🍳 🥘 🍲 🥣 🥗 🍿 🧈 🧂 🥫 food-asian 🍱 🍘 🍙 🍚 🍛 🍜 🍝 🍠 🍢 🍣 🍤 🍥 🥮 🍡 🥟 🥠 🥡 food-marine 🦀 🦞 🦐 🦑 🦪 food-sweet 🍦 🍧 🍨 🍩 🍪 🎂 🍰 🧁 🥧 🍫 🍬 🍭 🍮 🍯 drink 🍼 🥛 ☕ 🍵 🍶 🍾 🍷 🍸 🍹 🥂 🥃 🥤 🧃 🧉 🧊 dishware 🥢 🍽 🍴 🥄 🔪 🏺 Travel & Places place-map 🌍 🌎 🌏 🌐 🗺 🗾 🧭 place-geographic 🏔 ⛰ 🌋 🗻 🏕 🏖 🏜 🏝 🏞 place-building 🏟 🏛 🏗 🧱 🏘 🏚 🏠 🏡 🏢 🏣 🏤 🏥 🏦 🏨 🏩 🏪 🏫 🏬 🏭 🏯 🏰 💒 🗽 place-religious ⛪ 🕌 🛕 🕍 ⛩ 🕋 place-other ⛲ ⛺ 🌁 🌃 🏙 🌄 🌅 🌆 🌇 🌉 ♨ 🎠 🎡 🎢 💈 🎪 transport-ground 🚂 🚃 🚄 🚅 🚆 🚇 🚈 🚉 🚊 🚝 🚞 🚋 🚌 🚍 🚎 🚐 🚑 🚒 🚓 🚔 🚕 🚖 🚗 🚘 🚙 🚚 🚛 🚜 🏎 🏍 🛵 🦽 🦼 🛺 🚲 🛴 🛹 🚏 🛣 🛤 🛢 ⛽ 🚨 🚥 🚦 🛑 🚧 transport-water ⚓ ⛵ 🛶 🚤 🛳 ⛴ 🛥 🚢 transport-air ✈ 🛩 🛫 🛬 🪂 💺 🚁 🚟 🚠 🚡 🛰 🚀 🛸 hotel 🛎 🧳 time ⌛ ⏳ ⌚ ⏰ ⏱ ⏲ 🕰 🕛 🕧 🕐 🕜 🕑 🕝 🕒 🕞 🕓 🕟 🕔 🕠 🕕 🕡 🕖 🕢 🕗 🕣 🕘 🕤 🕙 🕥 🕚 🕦 sky & weather 🌑 🌒 🌓 🌔 🌕 🌖 🌗 🌘 🌙 🌚 🌛 🌜 🌡 ☀ 🌝 🌞 🪐 ⭐ 🌟 🌠 🌌 ☁ ⛅ ⛈ 🌤 🌥 🌦 🌧 🌨 🌩 🌪 🌫 🌬 🌀 🌈 🌂 ☂ ☔ ⛱ ⚡ ❄ ☃ ⛄ ☄ 💧 🌊 Activities event 🎃 🎄 🎆 🎇 🧨 ✨ 🎈 🎉 🎊 🎋 🎍 🎎 🎏 🎐 🎑 🧧 🎀 🎁 🎗 🎟 🎫 award-medal 🎖 🏆 🏅 🥇 🥈 🥉 sport ⚾ 🥎 🏐 🏈 🏉 🎾 🥏 🎳 🏏 🏑 🏒 🥍 🏓 🏸 🥊 🥋 🥅 ⛳ ⛸ 🎣 🤿 🎽 🎿 🛷 🥌 game 🎯 🪀 🪁 🎱 🔮 🧿 🎮 🕹 🎰 🎲 🧩 🧸 ♠ ♥ ♦ ♣ ♟ 🃏 🀄 🎴 arts & crafts 🎭 🖼 🎨 🧵 🧶 Objects clothing 👓 🕶 🥽 🥼 🦺 👔 👕 👖 🧣 🧤 🧥 🧦 👗 👘 🥻 🩱 🩲 🩳 👙 👚 👛 👜 👝 🛍 🎒 👞 🥾 🥿 👠 👡 🩰 👢 👑 👒 🎩 🎓 🧢 ⛑ 📿 💄 💍 💎 sound 🔇 🔈 🔉 🔊 📢 📣 📯 🔔 🔕 music 🎼 🎵 🎶 🎙 🎚 🎛 🎤 🎧 📻 musical-instrument 🎷 🎸 🎹 🎺 🎻 🪕 🥁 phone 📱 📲 ☎ 📞 📟 📠 computer 🔋 🔌 💻 🖥 🖨 ⌨ 🖱 🖲 💽 💾 💿 📀 🧮 light & video 🎥 🎞 📽 🎬 📺 📷 📸 📹 📼 🔍 🔎 🕯 💡 🔦 🏮 🪔 book-paper 📔 📕 📖 📗 📘 📙 📚 📓 📒 📃 📜 📄 📰 🗞 📑 🔖 🏷 money 💰 💴 💵 💶 💷 💸 💳 🧾 💹 💱 💲 mail ✉ 📧 📨 📩 📤 📥 📦 📫 📪 📬 📭 📮 🗳 writing ✏ ✒ 🖋 🖊 🖌 🖍 📝 office 💼 📁 📂 🗂 📅 📆 🗒 🗓 📇 📈 📉 📊 📋 📍 📎 🖇 📏 📐 ✂ 🗃 🗄 🗑 lock 🔒 🔓 🔏 🔐 🔑 🗝 tool 🪓 ⛏ ⚒ 🛠 🗡 ⚔ 🔫 🏹 🛡 🔧 🔩 ⚙ 🗜 ⚖ 🦯 🔗 ⛓ 🧰 🧲 science ⚗ 🧪 🧫 🧬 🔬 🔭 📡 medical 🩸 💊 🩹 🩺 household 🚪 🛏 🛋 🪑 🚽 🚿 🛁 🪒 🧴 🧷 🧹 🧺 🧻 🧼 🧽 🧯 🛒 other-object 🚬 ⚰ ⚱ 🗿 Symbols transport-sign 🏧 🚮 🚰 ♿ 🚹 🚺 🚻 🚼 🚾 🛂 🛃 🛄 🛅 warning ⚠ 🚸 ⛔ 🚫 🚳 🚭 🚯 🚱 🚷 📵 🔞 ☢ ☣ arrow ⬆ ↗ ➡ ↘ ⬇ ↙ ⬅ ↖ ↕ ↔ ↩ ↪ ⤴ ⤵ 🔃 🔄 🔙 🔚 🔛 🔜 🔝 religion 🛐 ⚛ 🕉 ✡ ☸ ☯ ✝ ☦ ☪ ☮ 🕎 🔯 zodiac ♈ ♉ ♊ ♋ ♌ ♍ ♎ ♏ ♐ ♑ ♒ ♓ ⛎ av-symbol 🔀 🔁 🔂 ▶ ⏩ ⏭ ⏯ ◀ ⏪ ⏮ 🔼 ⏫ 🔽 ⏬ ⏸ ⏹ ⏺ ⏏ 🎦 🔅 🔆 📶 📳 📴 gender ♀ ♂ other-symbol ⚕ ♾ ♻ ⚜ 🔱 📛 🔰 ⭕ ✅ ☑ ✔ ✖ ❌ ❎ ➕ ➖ ➗ ➰ ➿ 〽 ✳ ✴ ❇ ‼ ⁉ ❓ ❔ ❕ ❗ 〰 © ® ™ alphanum 🔠 🔡 🔢 🔣 🔤 🅰 🆎 🅱 🆑 🆒 🆓 ℹ 🆔 Ⓜ 🆕 🆖 🅾 🆗 🅿 🆘 🆙 🆚 🈁 🈂 🈷 🈶 🈯 🉐 🈹 🈚 🈲 🉑 🈸 🈴 🈳 ㊗ ㊙ 🈺 🈵 geometric 🔴 🟠 🟡 🟢 🔵 🟣 🟤 ⚫ ⚪ 🟥 🟧 🟨 🟩 🟦 🟪 🟫 ⬛ ⬜ ◼ ◻ ◾ ◽ ▪ ▫ 🔶 🔷 🔸 🔹 🔺 🔻 💠 🔘 🔳 🔲 Flags flag 🏁 🚩 🎌 🏴 🏳 🏳️‍🌈 🏴‍☠️ subdivision-flag 🏴󠁧󠁢󠁥󠁮󠁧󠁿 🏴󠁧󠁢󠁳󠁣󠁴󠁿 🏴󠁧󠁢󠁷󠁬󠁳󠁿 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-21 16:45:42 "},"else/YiyunShare.html":{"url":"else/YiyunShare.html","title":"亦云分享调研","keywords":"","body":" 亦云分享调研 目标：获取手机号及填写表单信息回传 微信开放平台官方文档 IOS Android 平台使用的第三方sdk 网站 微信小程序 条件 传统APP要以小程序卡片的形式分享到微信，需要满足以下几个条件： 发起分享的App与小程序属于同一微信开放平台帐号； 支持分享小程序类型消息至会话，暂不支持分享至朋友圈； 若客户端版本低于6.5.6或在iPad客户端接收，小程序类型分享将自动转成网页类型分享。开发者必须填写网页链接字段，确保低版本客户端能正常打开网页链接； 限制大小不超过128KB，自定义图片建议长宽比是 5:4。6.5.9及以上版本微信客户端小程序类型分享使用大图卡片样式。 优劣势 优势 直接获取手机号 代码更独立 劣势 开发周期会更久 疑问 可能出现该用户未在亦云注册的情况，回传判断会出现问题 微信公众号 条件 不支持app直接跳转到微信公众号且无法获取手机号 H5页面 条件 必须有一个放置网页的域名和服务器 优劣势 优势 开发周期会相对较短，只需移植移动端的部分代码 劣势 无法直接获取手机号 如果移动端存在问题，此处也会存在问题 疑问 如果在提交阶段填写手机号，可能出现该用户未在亦云注册的情况，回传会出现问题 token的获取，如何获取到亦云的sdk还是脱离亦云的sdk 返回亦云/下载亦云 条件 无 优劣势 优势 不需要额外开发，在原先业务上判断即可 劣势 对于未下载亦云用户无法判断 疑问 如已下载亦云，如何跳转指定项目并将对应参数传入 未下载用户下载完怎么填写，是否需再次点击链接 Copyright © renshihao.cn 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 13:11:16 "}}